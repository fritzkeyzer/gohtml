package gohtml

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"path/filepath"
)

func (t *Template) Generate(w io.Writer) {
	buf := &bytes.Buffer{}

	t.writeFileHeader(buf)

	for _, fn := range t.Functions {
		for _, structDef := range fn.Types {
			t.writeStructDef(buf, structDef)
		}

		t.writeFunction(buf, fn)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	_, err = w.Write(formatted)
	if err != nil {
		panic(err)
	}
}

func (t *Template) writeFileHeader(w io.Writer) {
	fmt.Fprintf(w, `// Code generated by gohtml. DO NOT EDIT

//go:build !ignore_autogenerated

package %[1]s

import (
	"bytes"
	_ "embed"
	"html/template"
	"io"
)

//go:embed %[2]s
var %[3]sTemplate string

`,
		t.PackageName,
		filepath.Base(t.FilePath),
		t.Name,
	)
}

func (t *Template) writeFunction(w io.Writer, fn FuncDef) {
	if len(fn.Types) == 0 {
		fmt.Fprintf(w, `// %[1]s renders the "%[1]s" template as an HTML fragment
func %[1]s() template.HTML {
	buf := new(bytes.Buffer)
	err := Render%[1]s(buf)
	if err != nil {
		panic(err)
	}

	return template.HTML(buf.String())
}

// Render%[1]s renders the "%[1]s" template to the specified writer
func Render%[1]s(w io.Writer) error {
	var tmpl *template.Template
	var err error
	if LiveReload {
		tmpl, err = template.ParseFiles("%[2]s")
	} else {
		tmpl, err = template.New("%[1]s").Parse(%[1]sTemplate)
	}
	if err != nil {
		return err
	}

	return tmpl.Execute(w, nil)
}
`,
			t.Name,
			t.FilePath,
		)
		return
	}

	fmt.Fprintf(w, `// %[1]s renders the "%[1]s" template as an HTML fragment
func %[1]s(data %[1]sData) template.HTML {
	buf := new(bytes.Buffer)
	err := Render%[1]s(buf, data)
	if err != nil {
		panic(err)
	}

	return template.HTML(buf.String())
}

// Render%[1]s renders the "%[1]s" template to the specified writer
func Render%[1]s(w io.Writer, data %[1]sData) error {
	var tmpl *template.Template
	var err error
	if LiveReload {
		tmpl, err = template.ParseFiles("%[2]s")
	} else {
		tmpl, err = template.New("%[1]s").Parse(%[1]sTemplate)
	}
	if err != nil {
		return err
	}

	return tmpl.Execute(w, data)
}
`,
		t.Name,
		t.FilePath,
	)
}

func (t *Template) writeStructDef(w io.Writer, structDef StructDef) {
	fields := ""
	for _, field := range structDef.Fields {
		fields += "\t" + field.Name + " " + field.Type + "\n"
	}

	fmt.Fprintf(w, `type %[1]s struct {
%[2]s}

`,
		structDef.Name,
		fields,
	)
}
