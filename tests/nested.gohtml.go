// Code generated by gohtml. DO NOT EDIT

//go:build !ignore_autogenerated

package tests

import (
	"bytes"
	"html/template"
	"io"
	"net/http"
)

// --- START TEMPLATE: Nested

var rawNestedTemplate =
// language=gotemplate
`<h1>{{.Organisation.Name}}</h1>
<p>{{.Organisation.Founded}}</p>
<div>
    <p>{{.Employee.Personal.Address.Street}}</p>
    <p>{{.Employee.Personal.Address.City}}</p>
    <p>{{.Employee.Personal.Address.Country}}</p>
</div>
`

var NestedTemplate = template.Must(template.New("Nested").Parse(rawNestedTemplate))

type NestedData struct {
	Organisation NestedOrganisation
	Employee     NestedEmployee
}

type NestedEmployee struct {
	Personal NestedEmployeePersonal
}

type NestedEmployeePersonal struct {
	Address NestedEmployeePersonalAddress
}

type NestedEmployeePersonalAddress struct {
	Street  any
	City    any
	Country any
}

type NestedOrganisation struct {
	Name    any
	Founded any
}

// Nested renders the "Nested" template as an HTML fragment
func Nested(data NestedData) template.HTML {
	buf := new(bytes.Buffer)
	err := RenderNested(buf, data)
	if err != nil {
		panic(err)
	}

	return template.HTML(buf.String())
}

// RenderNested renders the "Nested" template to the specified writer.
// If the writer is of the type http.ResponseWriter - the content-type header is set to "text/html; charset=utf-8"
func RenderNested(w io.Writer, data NestedData) error {
	if hw, ok := w.(http.ResponseWriter); ok {
		hw.Header().Set("Content-Type", "text/html; charset=utf-8")
	}

	tmpl := NestedTemplate
	if LiveReload {
		var err error
		tmpl, err = template.ParseFiles("example/template/conditional.gohtml")
		if err != nil {
			return err
		}
	}

	return tmpl.Execute(w, data)
}

// --- END TEMPLATE: Nested
